cat("x * y=", z)
}
cat('x * y의 결과는 40이상입니다.')
score <-scan()
result <- "노력"
score <-scan()
score <-scan()
# 3개의 변수 선언 : 세미콜론으로 구분한다.
x <- 50; y <- 4; z <- x*y
if(x*y > 40){
cat('x * y의 결과는 40이상입니다.')
cat("x * y=", z)
}
# 사용자 입력1
score <-scan()
# 사용자 입력1
score <-scan()
if(score >= 80){
result <- "우수"
}
cat("당신의 학점 :",score)
cat(result, "입니다.")
result <- "노력"
cat(result, "입니다.")
if(score >= 80){
result <- "우수"
}
cat("당신의 학점 :",score)
cat(result, "입니다.")
jumsu <- scan()
if(jumsu >= 90){
result ="A학점"
}else if(jumsu >= 80){
result = "B학점"
}else if(jumsu >= 70){
result ="C학점"
}else if(jumsu >= 60){
result = "D학점"
}else{
result = "F학점"
}
install.packages("stringr")
library(stringr)
str = stringr::str_c(result, " : ", jumsu)
cat("당신의 학점은",str)
# switch() : 주어진 값에 따라 하나를 선택하여 실행하는 조건문
empname <- scan(what = "")
# switch() : 주어진 값에 따라 하나를 선택하여 실행하는 조건문
empname <- scan(what = "")
# switch() : 주어진 값에 따라 하나를 선택하여 실행하는 조건문
empname <- scan(what = "")
switch(empname,
"홍길동"= cat(100),
"전우치"= cat(200),
"손오공"= cat(300),
cat("같은 값이 없습니다."))
# switch() : 주어진 값에 따라 하나를 선택하여 실행하는 조건문
empname <- scan(what = "")
switch(empname,
"홍길동"= cat(100),
"전우치"= cat(200),
"손오공"= cat(300),
cat("같은 값이 없습니다."))
choice <- scan()
#숫자형인 경우에는 라벨을 별도로 기술하지 않고 1부터 순서대로 부여된다. 아래의 경우 1~3까지으 라벨이 생성된다.
result <- switch(choice,
"유비",
"관우",
"장비")
print(result)
choice <- scan()
print(result)
#숫자형인 경우에는 라벨을 별도로 기술하지 않고 1부터 순서대로 부여된다. 아래의 경우 1~3까지으 라벨이 생성된다.
result <- switch(choice,
"유비",
"관우",
"장비")
print(result)
# which() 함수
name <- c("홍길동","전우치","손오공","해리포터")
which(name == "전우치")
which(name == "유비")
which(name == "전우치")
which(name == "유비")
for(n in i){
if(n %% 2 == 0){
next
} else{
print(n)
}
}
# for() 함수
# c() 함수를 통해 1~10까지의 벡터를 생성
i <- c(1:10)
for(n in i){
if(n %% 2 == 0){
next
} else{
print(n)
}
}
# while() 함수
i = 0
while(i<10){
print(i)
i <- i + 1
}
# 함수1
fn1 <- function(){
cat("매개변수X, 반환값X\n")
2+3
}
fn1()
# 함수1
fn1 <- function(){
cat("매개변수X, 반환값X\n")
2+3
"문자"
}
fn1()
# 함수1
fn1 <- function(){
cat("매개변수X, 반환값X\n")
2+3
}
fn1()
myFn1 <- fn1()
View(fn1)
View(fn1)
myFn1
# 함수2
fn2 <- function(){
cat("매개변수X, 반환값0\n")
return (2+3)
}
# 함수의 반환값을 변수에 할당. <- 연산자 사용.
myFunc <- fn2()
myFunc
View(fn2)
# 함수3
fn3 <- function(x, y){
cat("매개변수0, 반환값X\n")
x + y
}
# return은 없으나 변수를 좌측에 설정하여 반환값을 받을 수 있음
fn3(2,3)
# return은 없으나 변수를 좌측에 설정하여 반환값을 받을 수 있음
fn3(2,3)
# 함수4
fn4 <- function(x,y){
cat("매개변수0, 반환값0\n")
return (x + y)
}
# 함수의 반환값을 변수에 할당. = 연산자 사용.
myFunc = fn4(2,3)
# 구구단 출력 함수
gugudan <- function(i,j){
for(dan in i){
for(su in j){
cat(dan, "*", su, "=", dan*su, " ")
}
cat("\n")
}
}
dan <- c(2:9)
su <- c(1:9)
gugudan(dan,su)
for(su in j){
cat(dan, "*", su, "=", dan*su, " ")
cat("\n")
}
gugudan(dan,su)
# 구구단 출력 함수
gugudan <- function(i,j){
for(dan in i){
for(su in j){
cat(dan, "*", su, "=", dan*su, " ")
cat("\n")
}
cat("\n")
}
}
# 각 범위의 벡터를 생성한 후 인수로 사용
dan <- c(2:9)
su <- c(1:9)
gugudan(dan,su)
# 문자열 위치 구하기 : 처음과 끝 부분의 인덱스 변환
strLoc <- str_locate(str01, "전우치")
str01 = "홍길동11전우치22손오공33Hello44"
library("stringr")
# 문자열 위치 구하기 : 처음과 끝 부분의 인덱스 변환
strLoc <- str_locate(str01, "전우치")
strLoc
# 문자열 분리
str08 = "홍길동, 저우치, 손오공, 해리포터"
str09 <- str_split(str08, ",")
str09
View(str09)
View(str09)
View(strLoc)
# 벡터 문자열로 합치기 : 콤마를 사용
str10 <- paste(str09, collapse = ",")
str10
# 문자열 분리
str08 = "홍길동, 저우치, 손오공, 해리포터"
str09 <- str_split(str08, ",")
str11 = c("홍길동","전우치","손오공", "해리포터")
str11 = c("홍길동","전우치","손오공", "해리포터")
# 벡터 문자열로 합치기 : 콤마를 사용
str10 <- paste(str09, collapse = ",")
str11 = c("홍길동","전우치","손오공", "해리포터")
# 문자열 분리
str08 = "홍길동, 저우치, 손오공, 해리포터"
library("stringr")
str09 <- str_split(str08, ",")
str09
# 벡터 문자열로 합치기 : 콤마를 사용
str10 <- paste(str09, collapse = ",")
str10
str11 = c("홍길동","전우치","손오공", "해리포터")
str11
str12 <- paste(str11, collapse =",")
str12
a <- 123
b <- '안녕하세요'
c <- 3.14
sprintf("정수 : %d", a)
sprintf("문자열 : %s", b)
sprintf("실수 : %f, %.2f", c, c)
# 자리수지정
sprintf("%5d",a)
sprintf("%5d", 123456)
# cat()과 print() 차이
for(i in 1:3) print(i) # 줄바꿈된다.
for(i in 1:3) cat(i) # 줄바꿈 없이 출력된다.
a <- 123
b <- '안녕하세요'
c <- 3.14
sprintf("정수 : %d", a)
sprintf("문자열 : %s", b)
sprintf("실수 : %f, %.2f", c, c)
# 자리수지정
sprintf("%5d",a)
sprintf("%5d", 123456)
# cat()과 print() 차이
for(i in 1:3) print(i) # 줄바꿈된다.
for(i in 1:3) cat(i) # 줄바꿈 없이 출력된다.
install.packages('ggplot2')
library(ggplot2)
alpha <- c('a','a','a','b','b','c')
qplot(alpha)
qplot(alpha, geom = "bar", main= "Bar Plot", xlab = "Category", ylab = "Count", fill= I("skyblue"))
?qplot
x <- rnorm(100)
y <- rnorm(100)
qplot(x, y, mian = "Scatter Plot", xlab = "X-axis", ylab = "Y-axis")
data <- rnorm(1000)
qplot(data, geom = "histogram", binwidth = 0.2, main= "Histogram", xlab = "Values", ylab = "Frequency", fill=I("lightblue"), col = I("black"))
alpha <- c('a','a','a','b','b','c')
qplot(alpha)
qplot(alpha, geom = "bar", main= "Bar Plot", xlab = "Category", ylab = "Count", fill= I("skyblue"))
?qplot
#산점도 생성
#rnorm() : 정규분포를 따르는 난수를 생성. 평균과 표준편차를 지정하면 그에 맞게 난수를 생성해준다.
x <- rnorm(100)
y <- rnorm(100)
qplot(x, y, mian = "Scatter Plot", xlab = "X-axis", ylab = "Y-axis")
english <- c(90, 80, 60, 70)
math <- c(50, 60, 100, 20)
df_midterm <- data.frame(english, math)
df_midterm
class <- c(1,1,2,2)
name <- c("홍길동", "전우치", "손오공", "해리포터")
df_midterm <- data.frame(english, math, class, name)
df_midterm
df_midterm <- cbind(df_midterm, age=c(25, 26, 27, 28))
df_midterm
df_midterm <- rbind(df_midterm, data.frame(english=50, math=50, class=3, name="멀린", age=30))
df_midterm
df_midterm2 <- data.frame(english2 = c(90, 80, 70, 60),
math2 = c(55, 66, 77, 88),
class2 = c(1,1,2,2),
name2 = c("유비", "관우","장비","조자룡"))
english2
View(df_midterm)
View(df_midterm2)
df_midterm <- data.frame(english, math)
df_midterm
View(df_midterm)
View(df_midterm2)
View(df_midterm)
class <- c(1,1,2,2)
name <- c("홍길동", "전우치", "손오공", "해리포터")
df_midterm <- data.frame(english, math, class, name)
df_midterm
df_midterm <- cbind(df_midterm, age=c(25, 26, 27, 28))
df_midterm
# 컬럼 추가
df_midterm <- cbind(df_midterm, age=c(25, 26, 27, 28,23))
# 컬럼 추가
df_midterm <- cbind(df_midterm, age=c(25, 26, 27, 28))
df_midterm
# 데이터 준비
english <- c(90, 80, 60, 70)
math <- c(50, 60, 100, 20)
#데이터프레임 만들기
df_midterm <- data.frame(english, math)
df_midterm
#데이터 추가1
class <- c(1,1,2,2)
name <- c("홍길동", "전우치", "손오공", "해리포터")
df_midterm <- data.frame(english, math, class, name)
df_midterm
# 컬럼 추가
df_midterm <- cbind(df_midterm, age=c(25, 26, 27, 28))
df_midterm
# 컬럼 추가 : cbind(기존데이터프레임, 추가할 컬럼정보)
df_midterm <- cbind(df_midterm, age=c(25, 26, 27, 28))
df_midterm
# 데이터 추가2 : rbind(기존 데이터프레임, 새로운 데이터프레임)
df_midterm <- rbind(df_midterm, data.frame(english=50, math=50, class=3, name="멀린", age=30))
df_midterm
# 데이터 추가2 : rbind(기존 데이터프레임, 새로운 데이터프레임)
df_midterm <- rbind(df_midterm, data.frame(english=50, math=50, class=3, name="멀린", age=30))
df_midterm
df_midterm2 <- data.frame(english2 = c(90, 80, 70, 60),
math2 = c(55, 66, 77, 88),
class2 = c(1,1,2,2),
name2 = c("유비", "관우","장비","조자룡"))
#간단한 분석
# 영어의 평균
mean(df_midterm2$english2)
# 수학의 최대값
max(df_midterm2$math2)
# 데이터 파일 읽기
# 작업 디렉토리 지정 및 확인
setwd("C:\workspace\R\resData")
# 작업 디렉토리 지정 및 확인
setwd("C:\workspace\R\resData")
# 작업 디렉토리 지정 및 확인
setwd("C:\workspace\R")
# 작업 디렉토리 지정 및 확인
setwd("C:\\workspace\R")
# 작업 디렉토리 지정 및 확인
setwd("C:\\workspace\\R")
# 작업 디렉토리 지정 및 확인
setwd("C:/workspace/R")
# 작업 디렉토리 지정 및 확인
setwd("C:/workspace/R")
getwd()
df_txt_exam1 <- read.table("./resData/txt_exam1.txt", header=1)
df_txt_exam1
View(df_txt_exam1)
# csv 파일은 별도의 패키지 없이 내장 함수를 사용해서 읽을 수 있다.
df_csv_exam1 <- read.csv("./resData/csv_exam1.csv")
df_csv_exam1
# 문자가 들어있는 파일을 읽을 때는 stringsAsFactors = F 로 설정
df_csv_exam2 <- read.csv("./resData/csv_exam2.csv", stringsAsFactors = F, fileEncoding ='utf-8', encoding="utf-8")
df_csv_exam2
# 컬럼명이 없고 구분자가 | 인 파일 읽어오기
df_csv_exam3 <- read.csv("./resData/csv_exam3.csv", sep="|", header = F)
df_csv_exam3
# 컬럼명 변경하기
names(df_csv_exam) <- c("id","class","math","english", "science")
df_csv_exam3
View(df_csv_exam1)
View(df_csv_exam1)
#----------------------------------------------
install.packages("readxl")
library(readxl)
df_excel <- read_excel("./resData/exam.xlsx")
df_excel
# 첫번째 해잉 변수명이 아닐때
df_excel_novar <- read_excel("./resData/excel_exam_novar.xlsx", col_names =F)
df_excel_novar
View(df_excel_novar)
# 엑셀 파일의 시트가 여러개 있을때 (여기서는 세번째 시트를 읽음)
df_excel_sheet <- read_excel("./resData/excel_exam_sheet.xlsx", sheet =3)
df_excel_sheet
df_exam <- read_excel("./resData/excel_exam_sheet.xlsx", col_names = F, sheet=3)
df_exam
View(df_excel_novar)
View(df_excel_sheet)
df_excel_sheet
df_txt_exam1
df_csv_exam1
df_excel_novar
write.table(df_txt_exam1,file= "./saveFiles/test.txt")
write.table(df_csv_exam1, file="./saveFiles/test.csv")
install.packages("xlsx")
library(xlsx)
write.xlsx(df_excel, file="./saveFiles/test.xlsx")
save(df_csv_exam1, file = "./saveFiles/test.rda")
rm(df_csv_exam1)
df_csv_exam1
laad("./saveFiles/test.rda")
df_csv_exam1
write.xlsx(df_excel, file="./saveFiles/test.xlsx")
install.packages("xlsx")
library(xlsx)
write.xlsx(df_excel, file="./saveFiles/test.xlsx")
save(df_csv_exam1, file = "./saveFiles/test.rda")
df_excel_exam1
write.xlsx(df_excel, file="./saveFiles/test.xlsx")
df_excel
library(readxl)
df_excel <- read_excel("./resData/exam.xlsx")
df_excel <- read_excel("./resData/excel_exam.xlsx")
df_excel
df_excel
write.xlsx(df_excel, file="./saveFiles/test.xlsx")
# 데이터 로딩
exam <- read.csv("./resData/csv_exam1.csv")
# 앞에서부터 6행까지 출력
head(exam)
# 데이터 로딩
exam <- read.csv("./resData/csv_exam1.csv")
# 앞에서부터 6행까지 출력
head(exam)
View(exam)
# 앞에서부터 10행까지 출력
head(exam, 10)
# 뒤에서부터 6행까지 출력
tail(exam)
#데이터 뷰어 창에서 데이터 확인(대문자 V로 시작)
View(exam)
#데이터가 몇행 몇열로 구성되어 있는지 출력
dim(exam)
#데이터의 속성 파악
str(exam)
#요약 통계량 산출
summary(exam)
# 상자 그래프(중아값, 사분위수, 이상치 등을 한눈에 파악할 수잇는 그래프)
boxplot(exam$math)
# ggplot2 패키지 로드
library(ggplot2)
# mpg 데이터 준비
# data("mpg") # ggplot2에 내장된 mpg 데이터 불러오기
mpg <- as.data.frame(ggplot2::mpg) # 새로운 데이터프레임 생성
# head(mpg)
# tail(mpg)
# view(mpg)
# dim(mpg)
# str(mpg)
# summary(mpg)
# ?mpg
# 통합 연비 파생 변수 만들기
# 통합 연비 = (도시 연비 + 고속도로 연비) / 2
mpg$total <- (mpg$cty + mpg$hwy) / 2
# 히스토그램으로 통합 연비 분포 확인
hist(mpg$total,
main = "통합 연비 히스토그램",
xlab = "통합 연비",
col = "skyblue",
border = "white")
# 연비 기준값 정하기
# 기준값: 통합 연비 25 이상을 고연비로 간주
fuel_efficiency_threshold <- 25
# 조건문을 이용한 파생 변수 생성 (합격/불합격)
mpg$pass_fail <- ifelse(mpg$total >= fuel_efficiency_threshold,
"합격", "불합격")
# 빈도표 생성
pass_fail_table <- table(mpg$pass_fail)
print(pass_fail_table)
# 막대 그래프로 합격/불합격 빈도 표현
barplot(pass_fail_table,
main = "연비 합격/불합격 빈도",
col = c("tomato", "steelblue"),
names.arg = c("불합격", "합격"),
ylab = "빈도",
xlab = "판정")
# 중첩 조건문 활용한 등급 변수 생성
# 등급 분류 기준:
# A: 통합 연비 >= 30
# B: 25 <= 통합 연비 < 30
# C: 20 <= 통합 연비 < 25
# D: 통합 연비 < 20
mpg$grade <- ifelse(mpg$total >= 30, "A",
ifelse(mpg$total >= 25, "B",
ifelse(mpg$total >= 20, "C", "D")))
# 등급 빈도표 생성
grade_table <- table(mpg$grade)
print(grade_table)
# 막대 그래프로 등급 빈도 표현
barplot(grade_table,
main = "통합 연비 등급 빈도",
col = c("gold", "lightgreen", "skyblue", "gray"),
names.arg = c("A", "B", "C", "D"),
ylab = "빈도",
xlab = "등급")
?mpg
head(mpg)
# 통합 연비 파생 변수 만들기
# 통합 연비 = (도시 연비 + 고속도로 연비) / 2
mpg$total <- (mpg$cty + mpg$hwy) / 2
mpg
# 히스토그램으로 통합 연비 분포 확인
hist(mpg$total,
main = "통합 연비 히스토그램",
xlab = "통합 연비",
col = "skyblue",
border = "white")
# 연비 기준값 정하기
# 기준값: 통합 연비 25 이상을 고연비로 간주
fuel_efficiency_threshold <- 25
# 막대 그래프로 등급 빈도 표현
barplot(grade_table,
main = "통합 연비 등급 빈도",
col = c("gold", "lightgreen", "skyblue", "gray"),
names.arg = c("A", "B", "C", "D"),
ylab = "빈도",
xlab = "등급")
